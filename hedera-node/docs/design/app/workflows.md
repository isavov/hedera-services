### Workflow Onset

At the beginning of each workflow, a `Transaction` has to be parsed and validated.
As these steps are the same for all workflows, this functionality has been extracted and made available independently.
All related classes can be found in the package `com.hedera.node.app.workflows.onset`.
Details about the required pre-checks can be found [here](transaction-prechecks.md).

### Ingest Workflow

The package `com.hedera.node.app.workflows.ingest` contains the ingest workflow. A rough overview can be seen in the diagram below.

![Diagram of ingest workflow](images/Ingest%20Workflow.drawio.png)

When a new message arrives at the HAPI-endpoint, the byte-buffer that contains the transaction is sent to the ingest workflow.
The gRPC-server is responsible for `Thread`-Management.
The ingest-workflow is single-threaded, but multiple calls can run in parallel.

The ingest workflow consists of the following steps:

0. **Check node.** The node is checked to ensure it is not in a state that prevents it from processing transactions.
1. **Parse transaction.** The transaction arrives as a byte-array. The required parts are parsed and the structure and syntax are validated.
2. **Deduplicate.** The transaction is checked to ensure it has not been processed before.
3. **Check throttles.** Throttling must be observed and checked as early as possible.
4. **Get payer account.** The account data of the payer is read from the latest immutable state.
5. Account Balance
   1. **Check account balance.** The account of the payer is checked to ensure it is able to pay the fee.
   2. **Estimate fee.** Compute the fee that is required to pay for the transaction.
6. **Verify payer's signature.** The signature of the payer is checked. (Please note: other signatures are not checked here, but in later stages)
7. **Submit to platform.** The transaction is submitted to the platform for further processing.
8. **TransactionResponse.** Return `TransactionResponse`  with result-code.

If all checks have been successful, the transaction has been submitted to the platform and the precheck-code of the returned `TransactionResponse` is `OK`.
Otherwise the transaction is rejected with an appropriate response code.
In case of insufficient funds, the returned `TransactionResponse` also contains an estimation of the required fee.

### Pre-Handle Workflow

The `com.hedera.node.app.workflows.prehandle` package contains the workflow for pre-handling transactions. A rough overview can be seen in the diagram below.

![Diagram of pre-handle transaction workflow](images/Pre-Handle%20Transaction%20Workflow.drawio.png)

An `Event` at a time is sent to the `prehandle` with a reference to the latest immutable state.
It iterates through each transaction and initiates the pre-handle workflow in a separate thread.
The workflow consists of the following steps:

1. **Parse Transaction.** The transaction arrives as a byte-array. The required parts are parsed and the common information is validated.
2. **Call PreTransactionHandler.** Depending on the type of transaction, a specific `PreTransactionHandler` is called. It validates the transaction-specific parts and pre-loads data into the cache. It also creates a `TransactionMetadata` and sets the required keys.
3. **Prepare Signature-Data.** The data for all signatures is loaded into memory. A signature consists of three parts:
   1. Some bytes that are signed; in our case, either the `bodyBytes` for an Ed25519 signature or the Keccak256 hash of the `bodyBytes` for an ECDSA(secp256k1) signature.
   2. An Ed25519 or secp256k1 public key that is supposed to have signed these bytes (these public keys come from e.g. the Hedera key of some `0.0.X` account).
   3. The signature itself---which comes from the `SignatureMap`, based on existence of a unique `SignaturePair` entry whose `pubKeyPrefix` matches the public key in (ii.).
4. **Verify Signatures.** The information prepared in the previous step is sent to the platform to validate the signatures.
5. **Transaction Metadata.** The `TransactionMetadata` generated by the `PreTransactionHandler` is attached to the `SwirldsTransaction`.

If all checks have been successful, the status of the created `TransactionMetadata` will be `OK`. 
Otherwise, the status is set to the response code providing the failure reason. 
If the workflow terminates early (either because the parsing step (1.) fails or an unexpected `Exception` occurs) an `ErrorTransactionMetadata` is attached to the `SwirldsTransaction` that contains the causing `Exception`.

### Query Workflow

The query workflow is quite complex.
Unlike transaction processing, it is not split into several phases, but covers the whole query from receiving the request until sending the response.
Also, a query typically contains a `CryptoTransfer` to cover the costs.

![Diagram of query worflow](images/Query%20Workflow.drawio.png)

When a query arrives at the HAPI-endpoint, the byte-buffer that contains the query is sent to the query workflow.
The gRPC-server is responsible for `Thread`-management.
The query-workflow is single-threaded, but multiple calls can run in parallel.

The query workflow consists of the following steps:

1. **Parse and check header.** The query arrives as a byte-array. The required parts are parsed and the type of the query (header) is extracted and validated.
2. **Check node.** The node is checked to ensure it is not in a state that prevents it from processing transactions.
3. **Check query throttles.** Throttling must be observed and checked as early as possible.
4. If a payment is required:
   1. **Ingest checks.** Run all checks of the ingest workflow on the `CryptoTransfer`.
   2. **Validate the CryptoTransfer.** The contained `CryptoTransfer` is validated.
   3. **Check permissions.** It is checked, if the requester is actually allowed to do the query.
   4. **Calculate costs.** The costs of the query are calculated.
   5. **Check account balances.** The accounts of all payers are checked.
5. **Check validity.** The query is checked semantically.
6. **Submit payment to platform.** If a payment is required, the contained `CryptoTransfer` is submitted to the platform.
7. The last step depends on what was requested
   1. **Estimate costs.** If only the costs are requested, they are estimated. (Requests for costs are free, therefore the costs have not been calculated in step 3.)
   2. **Find response.** If the result of the query is expected (and not only the costs), the actual query is performed.

Depending on what was requested, either the result of the query or the expected costs are returned to the caller.
If at anytime an error occurs, a response with the error code is returned.